name: Create auth feature PR
on:
  workflow_dispatch:

jobs:
  create-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node (for any scripts)
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Create directories
        run: |
          mkdir -p routes services middleware migrations

      - name: Add services/authService.js
        run: |
          cat > services/authService.js <<'EOF'
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const ACCESS_EX_DEFAULT = '15m';
const REFRESH_EX_DEFAULT = '7d';

function parseEnvExpiry(envValue, fallback) {
  if (!envValue) return fallback;
  return envValue;
}

async function hashPassword(plain) {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(plain, salt);
}

async function comparePassword(plain, hash) {
  if (!hash) return false;
  return bcrypt.compare(plain, hash);
}

function issueAccessToken(payload) {
  const secret = process.env.JWT_SECRET;
  const expiresIn = parseEnvExpiry(process.env.ACCESS_TOKEN_EXPIRES, ACCESS_EX_DEFAULT);
  return jwt.sign(payload, secret, { expiresIn });
}

function issueRefreshToken(payload) {
  const secret = process.env.JWT_REFRESH_SECRET;
  const expiresIn = parseEnvExpiry(process.env.REFRESH_TOKEN_EXPIRES, REFRESH_EX_DEFAULT);
  return jwt.sign(payload, secret, { expiresIn });
}

function verifyAccessToken(token) {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (e) {
    return null;
  }
}

function verifyRefreshToken(token) {
  try {
    return jwt.verify(token, process.env.JWT_REFRESH_SECRET);
  } catch (e) {
    return null;
  }
}

module.exports = {
  hashPassword,
  comparePassword,
  issueAccessToken,
  issueRefreshToken,
  verifyAccessToken,
  verifyRefreshToken,
};
EOF

      - name: Add middleware/auth.js
        run: |
          cat > middleware/auth.js <<'EOF'
const { verifyAccessToken } = require('../services/authService');

function authenticateToken(req, res, next) {
  const auth = req.headers['authorization'];
  if (!auth) return res.status(401).json({ error: 'Missing Authorization header' });
  const parts = auth.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') return res.status(401).json({ error: 'Invalid Authorization format' });
  const token = parts[1];
  const payload = verifyAccessToken(token);
  if (!payload) return res.status(401).json({ error: 'Invalid or expired token' });
  req.user = payload; // expected to contain { id, role, group_id } from issuance
  next();
}

function requireRole(role) {
  return (req, res, next) => {
    if (!req.user) return res.status(401).json({ error: 'Not authenticated' });
    if (req.user.role !== role) return res.status(403).json({ error: 'Forbidden' });
    next();
  };
}

function requireOwnerOrAdmin(req, res, next) {
  if (!req.user) return res.status(401).json({ error: 'Not authenticated' });
  const targetUserId = Number(req.params.id);
  if (req.user.role === 'ADMIN' || req.user.id === targetUserId) return next();
  return res.status(403).json({ error: 'Forbidden' });
}

module.exports = {
  authenticateToken,
  requireRole,
  requireOwnerOrAdmin,
};
EOF

      - name: Add routes/auth.js
        run: |
          cat > routes/auth.js <<'EOF'
const express = require('express');
const router = express.Router();
const { Client } = require('pg');
const rateLimit = require('express-rate-limit');
const { hashPassword, comparePassword, issueAccessToken, issueRefreshToken, verifyRefreshToken } = require('../services/authService');

const loginLimiter = rateLimit({ windowMs: 60 * 1000, max: 6, message: { error: 'Too many login attempts, try later' } });

function createClient() {
  return new Client({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } });
}

function parseExpiryToMs(ex) {
  if (!ex) return 7 * 24 * 3600 * 1000;
  if (ex.endsWith('m')) return parseInt(ex.slice(0, -1), 10) * 60 * 1000;
  if (ex.endsWith('d')) return parseInt(ex.slice(0, -1), 10) * 24 * 3600 * 1000;
  return 7 * 24 * 3600 * 1000;
}

// POST /api/groups
router.post('/groups', async (req, res) => {
  const { groupName, adminEmail, adminNickname, password, type, birthYear } = req.body || {};
  if (!groupName || !adminEmail || !adminNickname || !password) return res.status(400).json({ error: 'Missing fields' });
  const client = createClient();
  await client.connect();
  try {
    await client.query('BEGIN');
    const check = await client.query('SELECT id FROM groups WHERE admin_email = $1', [adminEmail.trim().toLowerCase()]);
    if (check.rows.length > 0) { await client.query('ROLLBACK'); return res.status(400).json({ error: 'Email exists' }); }
    const g = await client.query('INSERT INTO groups (name, admin_email, type) VALUES ($1, $2, $3) RETURNING id, name, admin_email', [groupName, adminEmail.trim().toLowerCase(), type || 'FAMILY']);
    const hashed = await hashPassword(password);
    const u = await client.query(\`INSERT INTO users (group_id, nickname, password_hash, role, status, birth_year, balance) VALUES ($1, $2, $3, 'ADMIN', 'ACTIVE', $4, 0) RETURNING id, nickname, role, status, birth_year, balance\`, [g.rows[0].id, adminNickname, hashed, birthYear || null]);
    const cats = ['food', 'groceries', 'transport', 'bills', 'fun', 'clothes', 'health', 'education', 'other'];
    for (const c of cats) {
      await client.query(\`INSERT INTO budgets (group_id, user_id, category, limit_amount) VALUES ($1, NULL, $2, 0) ON CONFLICT DO NOTHING\`, [g.rows[0].id, c]);
    }
    await client.query('COMMIT');
    const payload = { id: u.rows[0].id, role: u.rows[0].role, group_id: g.rows[0].id };
    const accessToken = issueAccessToken(payload);
    const refreshToken = issueRefreshToken(payload);
    const maxAge = parseExpiryToMs(process.env.REFRESH_TOKEN_EXPIRES || '7d');
    res.cookie('refreshToken', refreshToken, { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'lax', maxAge });
    res.json({ success: true, user: u.rows[0], group: g.rows[0], accessToken });
  } catch (e) {
    await client.query('ROLLBACK');
    res.status(500).json({ error: e.message });
  } finally {
    client.end();
  }
});

// POST /api/join
router.post('/join', async (req, res) => {
  const { groupEmail, nickname, password, birthYear } = req.body || {};
  if (!groupEmail || !nickname || !password) return res.status(400).json({ error: 'Missing fields' });
  const client = createClient(); await client.connect();
  try {
    const g = await client.query('SELECT id FROM groups WHERE admin_email = $1', [groupEmail.trim().toLowerCase()]);
    if (g.rows.length === 0) return res.status(404).json({ error: 'Group not found' });
    const check = await client.query('SELECT id FROM users WHERE group_id = $1 AND LOWER(nickname) = LOWER($2)', [g.rows[0].id, nickname]);
    if (check.rows.length > 0) return res.status(400).json({ error: 'Nickname taken' });
    const hashed = await hashPassword(password);
    await client.query(\`INSERT INTO users (group_id, nickname, password_hash, role, status, birth_year, balance) VALUES ($1, $2, $3, 'MEMBER', 'PENDING', $4, 0)\`, [g.rows[0].id, nickname, hashed, birthYear || null]);
    res.json({ success: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

// POST /api/login
router.post('/login', loginLimiter, async (req, res) => {
  const { groupEmail, nickname, password } = req.body || {};
  if (!groupEmail || !nickname || !password) return res.status(400).json({ error: 'Missing credentials' });
  const client = createClient(); await client.connect();
  try {
    const g = await client.query('SELECT * FROM groups WHERE admin_email = $1', [groupEmail.trim().toLowerCase()]);
    if (g.rows.length === 0) return res.status(401).json({ error: 'Group not found' });
    const ures = await client.query('SELECT * FROM users WHERE group_id = $1 AND LOWER(nickname) = LOWER($2)', [g.rows[0].id, nickname]);
    if (ures.rows.length === 0) return res.status(401).json({ error: 'Invalid credentials' });
    const user = ures.rows[0];
    let valid = false;
    if (user.password_hash) {
      valid = await comparePassword(password, user.password_hash);
    } else if (user.password) {
      valid = (password === user.password);
      if (valid) {
        const h = await hashPassword(password);
        await client.query('UPDATE users SET password_hash=$1 WHERE id=$2', [h, user.id]);
      }
    }
    if (!valid) return res.status(401).json({ error: 'Invalid credentials' });
    if (user.status !== 'ACTIVE') return res.status(403).json({ error: 'Account pending' });
    await client.query('UPDATE users SET last_login = NOW() WHERE id = $1', [user.id]);
    const payload = { id: user.id, role: user.role, group_id: user.group_id };
    const accessToken = issueAccessToken(payload);
    const refreshToken = issueRefreshToken(payload);
    const maxAge = parseExpiryToMs(process.env.REFRESH_TOKEN_EXPIRES || '7d');
    res.cookie('refreshToken', refreshToken, { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'lax', maxAge });
    res.json({ success: true, user: { id: user.id, nickname: user.nickname, role: user.role, status: user.status, balance: user.balance }, group: g.rows[0], accessToken });
  } catch (e) { res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

// POST /api/auth/refresh
router.post('/auth/refresh', async (req, res) => {
  const token = req.cookies && req.cookies.refreshToken;
  if (!token) return res.status(401).json({ error: 'No refresh token' });
  const payload = verifyRefreshToken(token);
  if (!payload) return res.status(401).json({ error: 'Invalid refresh token' });
  const accessToken = issueAccessToken({ id: payload.id, role: payload.role, group_id: payload.group_id });
  res.json({ accessToken });
});

// POST /api/auth/logout
router.post('/auth/logout', async (req, res) => {
  res.clearCookie('refreshToken', { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'lax' });
  res.json({ success: true });
});

module.exports = router;
EOF

      - name: Add routes/users.js
        run: |
          cat > routes/users.js <<'EOF'
const express = require('express');
const router = express.Router();
const { Client } = require('pg');
const { authenticateToken, requireOwnerOrAdmin } = require('../middleware/auth');
const { hashPassword } = require('../services/authService');

function createClient() { return new Client({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } }); }

// GET /api/users/:id
router.get('/users/:id', authenticateToken, async (req, res) => {
  const id = Number(req.params.id);
  const client = createClient(); await client.connect();
  try {
    const ures = await client.query('SELECT id, nickname, role, status, birth_year, balance, group_id FROM users WHERE id=$1', [id]);
    if (ures.rows.length === 0) return res.status(404).json({ error: 'User not found' });
    const user = ures.rows[0];
    if (req.user.role !== 'ADMIN' && req.user.id !== user.id) return res.status(403).json({ error: 'Forbidden' });
    res.json(user);
  } catch (e) { res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

// PUT /api/users/:id  (update profile)
router.put('/users/:id', authenticateToken, requireOwnerOrAdmin, async (req, res) => {
  const id = Number(req.params.id);
  const { nickname, birth_year, password } = req.body || {};
  if (!nickname && !birth_year && !password) return res.status(400).json({ error: 'Nothing to update' });
  const client = createClient(); await client.connect();
  try {
    if (nickname) await client.query('UPDATE users SET nickname=$1 WHERE id=$2', [nickname, id]);
    if (birth_year !== undefined) await client.query('UPDATE users SET birth_year=$1 WHERE id=$2', [birth_year, id]);
    if (password) {
      const hashed = await hashPassword(password);
      await client.query('UPDATE users SET password_hash=$1 WHERE id=$2', [hashed, id]);
    }
    const ures = await client.query('SELECT id, nickname, role, status, birth_year, balance FROM users WHERE id=$1', [id]);
    res.json({ success: true, user: ures.rows[0] });
  } catch (e) { res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

// GET /api/group/members?groupId=123
router.get('/group/members', authenticateToken, async (req, res) => {
  const groupId = Number(req.query.groupId);
  if (!groupId) return res.status(400).json({ error: 'Missing groupId' });
  const client = createClient(); await client.connect();
  try {
    if (req.user.role !== 'ADMIN' && req.user.group_id !== groupId) return res.status(403).json({ error: 'Forbidden' });
    const r = await client.query("SELECT id, nickname, role, balance, allowance_amount, interest_rate FROM users WHERE group_id=$1 AND status='ACTIVE'", [groupId]);
    res.json(r.rows);
  } catch (e) { res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

module.exports = router;
EOF

      - name: Add routes/admin.js
        run: |
          cat > routes/admin.js <<'EOF'
const express = require('express');
const router = express.Router();
const { Client } = require('pg');
const { authenticateToken, requireRole } = require('../middleware/auth');

function createClient() { return new Client({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } }); }

const BUDGET_CATEGORIES = ['food','groceries','transport','bills','fun','clothes','health','education','other'];

// GET /api/admin/pending-users?groupId=123
router.get('/admin/pending-users', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  const groupId = Number(req.query.groupId);
  if (!groupId) return res.status(400).json({ error: 'Missing groupId' });
  const client = createClient(); await client.connect();
  try {
    const r = await client.query("SELECT id, nickname, birth_year FROM users WHERE group_id=$1 AND status='PENDING'", [groupId]);
    res.json(r.rows);
  } catch (e) { res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

// POST /api/admin/approve-user
router.post('/admin/approve-user', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  const { userId } = req.body || {};
  if (!userId) return res.status(400).json({ error: 'Missing userId' });
  const client = createClient(); await client.connect();
  try {
    await client.query('BEGIN');
    await client.query("UPDATE users SET status='ACTIVE' WHERE id=$1", [userId]);
    const u = await client.query("SELECT group_id FROM users WHERE id=$1", [userId]);
    if (u.rows.length > 0) {
      const gid = u.rows[0].group_id;
      for (const c of BUDGET_CATEGORIES) {
        const check = await client.query(\`SELECT id FROM budgets WHERE group_id=$1 AND category=$2 AND (user_id=$3 OR ($3::int IS NULL AND user_id IS NULL))\`, [gid, c, userId]);
        if (check.rows.length === 0) {
          await client.query(\`INSERT INTO budgets (group_id, user_id, category, limit_amount) VALUES ($1, $2, $3, 0)\`, [gid, userId, c]);
        }
      }
    }
    await client.query('COMMIT');
    res.json({ success: true });
  } catch (e) { await client.query('ROLLBACK'); res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

// POST /api/admin/spy/:targetUserId  (view-only)
router.post('/admin/spy/:targetUserId', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  const targetId = Number(req.params.targetUserId);
  const client = createClient(); await client.connect();
  try {
    const userQ = await client.query('SELECT id, nickname, role, status, balance FROM users WHERE id=$1', [targetId]);
    if (userQ.rows.length === 0) return res.status(404).json({ error: 'User not found' });
    const tasks = (await client.query('SELECT id, title, status, reward FROM tasks WHERE assigned_to=$1 ORDER BY created_at DESC LIMIT 50', [targetId])).rows;
    const shop = (await client.query('SELECT id, item_name, quantity, status FROM shopping_list WHERE requested_by=$1 ORDER BY id DESC LIMIT 50', [targetId])).rows;
    const goals = (await client.query('SELECT id, title, current_amount, target_amount FROM goals WHERE user_id=$1', [targetId])).rows;
    try {
      await client.query('INSERT INTO audit_logs ("actor_id", "target_id", "action", "created_at") VALUES ($1, $2, $3, NOW())', [req.user.id, targetId, 'spy_view']);
    } catch (e) {
      console.warn('audit log failed:', e.message);
    }
    res.json({ user: userQ.rows[0], tasks, shopping: shop, goals });
  } catch (e) { res.status(500).json({ error: e.message }); }
  finally { client.end(); }
});

module.exports = router;
EOF

      - name: Add migration SQL
        run: |
          cat > migrations/001_add_password_hash_and_timestamps.sql <<'EOF'
-- Adds password_hash and timestamp columns to users and audit_logs table for spy auditing.
BEGIN;

ALTER TABLE users
  ADD COLUMN IF NOT EXISTS password_hash TEXT,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  ADD COLUMN IF NOT EXISTS last_login TIMESTAMP;

CREATE TABLE IF NOT EXISTS audit_logs (
  id SERIAL PRIMARY KEY,
  actor_id INTEGER,
  target_id INTEGER,
  action VARCHAR(150),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- indexes
CREATE INDEX IF NOT EXISTS idx_users_group_id ON users(group_id);
CREATE INDEX IF NOT EXISTS idx_users_nickname_lower ON users ((LOWER(nickname)));

COMMIT;
EOF

      - name: Add .env.example and protected.json and README snippet
        run: |
          cat > .env.example <<'EOF'
# Database
DATABASE_URL=postgres://user:pass@localhost:5432/family_flow

# JWT
JWT_SECRET=your_access_token_secret_here
JWT_REFRESH_SECRET=your_refresh_token_secret_here
ACCESS_TOKEN_EXPIRES=15m
REFRESH_TOKEN_EXPIRES=7d

# App
PORT=3000
NODE_ENV=development
EOF

          cat > protected.json <<'EOF'
{
  "protected": [
    "public/index.html",
    "public/",
    "server.js",
    "routes/shopping.js",
    "services/shoppingService.js",
    "db/migrations/*shopping*.sql"
  ],
  "note": "Shopping related files are marked protected. Do not change them as per agreement."
}
EOF

          cat > README-auth-snippet.md <<'EOF'
# Local test checklist (after adding auth changes)

1. Add environment variables (use .env file matching .env.example)

2. Install new dependencies:
   npm install bcryptjs jsonwebtoken express-rate-limit cookie-parser dotenv

3. Run migration:
   psql "$DATABASE_URL" -f migrations/001_add_password_hash_and_timestamps.sql

   NOTE: If you have existing plaintext passwords in users.password, plan manual migration:
   - Option A: Ask users to reset passwords (recommended).
   - Option B: Manually set a temporary password for accounts and hash it into password_hash.

4. Start server:
   npm install
   npm start

5. Manual test flow:
   - POST /api/groups
     body: { groupName, adminEmail, adminNickname, password }
     Expect: success + user and group + accessToken in response and refresh cookie set.
   - POST /api/join
     body: { groupEmail, nickname, password }
     Expect: success (user created PENDING).
   - GET /api/admin/pending-users?groupId=<id> (ADMIN accessToken)
     Expect: list with joined user.
   - POST /api/admin/approve-user body: { userId } (ADMIN)
     Expect: user.status changed to ACTIVE.
   - POST /api/login body: { groupEmail, nickname, password }
     Expect: accessToken in body and Set-Cookie refresh token.
   - POST /api/auth/refresh (send refresh cookie)
     Expect: { accessToken }
   - POST /api/auth/logout
     Expect: success and refresh cookie cleared.
   - GET /api/users/:id (with Authorization: Bearer <accessToken>)
     Expect: user info (owner or ADMIN).
   - POST /api/admin/spy/:id (ADMIN only)
     Expect: read-only data (no session changes) and audit log entry in audit_logs table.

If anything fails, check the server logs for errors and ensure env vars set correctly.
EOF

      - name: Configure git
        run: |
          git config user.name "auto-pr-bot"
          git config user.email "action@localhost"

      - name: Create branch and commit files
        run: |
          BRANCH=feature/auth-bcrypt-jwt
          git checkout -b $BRANCH
          git add services middleware routes migrations protected.json .env.example README-auth-snippet.md
          git commit -m "chore: add auth bcrypt + JWT routes and middleware (auto PR)"
          git push --set-upstream origin $BRANCH

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: add auth bcrypt + JWT routes and middleware (auto PR)"
          title: "Add secure auth (bcrypt + JWT) and auth routes"
          body: |
            This PR adds secure authentication (bcrypt + JWT), auth routes, middleware and DB migration.
            Protected shopping module files: protected.json
