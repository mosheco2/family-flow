# Apply approved changes: create/update files on a feature branch, open PR (reuse if exists) and enable auto-merge
name: Apply approved changes (create branch + PR + auto-merge)
on:
  issue_comment:
    types: [created]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  apply-changes:
    runs-on: ubuntu-latest
    steps:
      - name: Validate trigger / authorized user
        uses: actions/github-script@v6
        id: validate
        with:
          script: |
            const commentBody = context.payload.comment ? context.payload.comment.body : '';
            const isDispatch = context.eventName === 'workflow_dispatch';
            const allowedUsers = ['mosheco2']; // <-- add other allowed users if needed
            const actor = context.payload.comment ? context.payload.comment.user.login : context.actor;

            if (!isDispatch && !commentBody.includes('/apply-changes')) {
              core.setFailed('No /apply-changes command found in the comment. Nothing to do.');
            }

            if (!allowedUsers.includes(actor)) {
              core.setFailed(`User "${actor}" is not authorized to run this workflow.`);
            }

            core.info(`Trigger accepted from "${actor}". Proceeding with changes...`);
            return { actor };

      - name: Create branch from main (if missing)
        uses: actions/github-script@v6
        id: create_branch
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const baseBranch = 'main';
            const newBranch = 'feature/auth-bcrypt-jwt';

            // get base sha
            const baseRef = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
            const baseSha = baseRef.data.object.sha;

            // check if branch exists
            try {
              await github.rest.git.getRef({ owner, repo, ref: `heads/${newBranch}` });
              core.info(`Branch ${newBranch} already exists.`);
            } catch (e) {
              // create ref
              await github.rest.git.createRef({ owner, repo, ref: `refs/heads/${newBranch}`, sha: baseSha });
              core.info(`Created branch ${newBranch} from ${baseBranch} (${baseSha}).`);
            }
            return { branch: newBranch };

      - name: Create/Update files and open PR (reuse existing PR if present)
        uses: actions/github-script@v6
        id: create_pr
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = 'feature/auth-bcrypt-jwt';
            const prTitle = 'Add secure auth (bcrypt + JWT) and auth routes (auto)';
            const prBody = 'This PR was created automatically after approval. Adds auth services, middleware, routes and DB migration.';

            // Files to create/update - build as arrays and join to avoid YAML/template literal issues
            const files = {
              "services/authService.js": [
                "const bcrypt = require('bcryptjs');",
                "const jwt = require('jsonwebtoken');",
                "",
                "const ACCESS_EX_DEFAULT = '15m';",
                "const REFRESH_EX_DEFAULT = '7d';",
                "",
                "function parseEnvExpiry(envValue, fallback) {",
                "  if (!envValue) return fallback;",
                "  return envValue;",
                "}",
                "",
                "async function hashPassword(plain) {",
                "  const salt = await bcrypt.genSalt(10);",
                "  return bcrypt.hash(plain, salt);",
                "}",
                "",
                "async function comparePassword(plain, hash) {",
                "  if (!hash) return false;",
                "  return bcrypt.compare(plain, hash);",
                "}",
                "",
                "function issueAccessToken(payload) {",
                "  const secret = process.env.JWT_SECRET;",
                "  const expiresIn = parseEnvExpiry(process.env.ACCESS_TOKEN_EXPIRES, ACCESS_EX_DEFAULT);",
                "  return jwt.sign(payload, secret, { expiresIn });",
                "}",
                "",
                "function issueRefreshToken(payload) {",
                "  const secret = process.env.JWT_REFRESH_SECRET;",
                "  const expiresIn = parseEnvExpiry(process.env.REFRESH_TOKEN_EXPIRES, REFRESH_EX_DEFAULT);",
                "  return jwt.sign(payload, secret, { expiresIn });",
                "}",
                "",
                "function verifyAccessToken(token) {",
                "  try {",
                "    return jwt.verify(token, process.env.JWT_SECRET);",
                "  } catch (e) {",
                "    return null;",
                "  }",
                "}",
                "",
                "function verifyRefreshToken(token) {",
                "  try {",
                "    return jwt.verify(token, process.env.JWT_REFRESH_SECRET);",
                "  } catch (e) {",
                "    return null;",
                "  }",
                "}",
                "",
                "module.exports = {",
                "  hashPassword,",
                "  comparePassword,",
                "  issueAccessToken,",
                "  issueRefreshToken,",
                "  verifyAccessToken,",
                "  verifyRefreshToken,",
                "};"
              ].join("\n"),

              "middleware/auth.js": [
                "const { verifyAccessToken } = require('../services/authService');",
                "",
                "function authenticateToken(req, res, next) {",
                "  const auth = req.headers['authorization'];",
                "  if (!auth) return res.status(401).json({ error: 'Missing Authorization header' });",
                "  const parts = auth.split(' ');",
                "  if (parts.length !== 2 || parts[0] !== 'Bearer') return res.status(401).json({ error: 'Invalid Authorization format' });",
                "  const token = parts[1];",
                "  const payload = verifyAccessToken(token);",
                "  if (!payload) return res.status(401).json({ error: 'Invalid or expired token' });",
                "  req.user = payload;",
                "  next();",
                "}",
                "",
                "function requireRole(role) {",
                "  return (req, res, next) => {",
                "    if (!req.user) return res.status(401).json({ error: 'Not authenticated' });",
                "    if (req.user.role !== role) return res.status(403).json({ error: 'Forbidden' });",
                "    next();",
                "  };",
                "}",
                "",
                "function requireOwnerOrAdmin(req, res, next) {",
                "  if (!req.user) return res.status(401).json({ error: 'Not authenticated' });",
                "  const targetUserId = Number(req.params.id);",
                "  if (req.user.role === 'ADMIN' || req.user.id === targetUserId) return next();",
                "  return res.status(403).json({ error: 'Forbidden' });",
                "}",
                "",
                "module.exports = {",
                "  authenticateToken,",
                "  requireRole,",
               
